<!-- Generated by Firebender -->

# Kotlin WindowFrequencyTracker Bug Review (2025-06-23 19:06:15)

_**User**_

you are a kotlin programming expert aware of the latest tools and apis of Kotlin.


i want a class that will report back how many times a certain block is run within certain time windows. for example, i will keep calling .run/.execute on this class, it will keep track of how many times execute was called within a certain time window.

How does @WindowFrequencyTracker.kt look? any possible bugs?

---

_**Assistant**_

Looking at the `WindowFrequencyTracker`, it has a good overall design but contains a **critical thread-safety bug**.

## Main Issue: Race Condition

The `frequencyThisWindow` variable is accessed from multiple threads without synchronization:
- Background coroutine reads/resets it every window
- Calling thread increments it via `mark()`

This can cause lost increments or incorrect counts.

## Additional Issues

1. **Memory leak potential** - If `cancel()` is never called, the coroutine runs forever
2. **Delayed first report** - First window report happens after full window duration, not immediately
3. **No exception handling** - Callback exceptions could crash the tracker

## Suggested Fix

```kotlin:common/utils/core/src/commonMain/kotlin/com/instacart/caper/common/utils/core/common/counters/WindowFrequencyTracker.kt
package com.instacart.caper.common.utils.core.common.counters

import kotlin.time.Duration
import kotlin.time.Duration.Companion.minutes
import kotlin.time.TimeSource
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import java.util.concurrent.atomic.AtomicInteger

class WindowFrequencyTracker(
    val timeSource: TimeSource = TimeSource.Monotonic,
    val window: Duration = 5.minutes,
    val onWindowCross: (frequencyThisWindow: Int) -> Unit,
) {
    private val frequencyThisWindow: AtomicInteger = AtomicInteger(0)
    private val scope: CoroutineScope = CoroutineScope(Dispatchers.Default)
    private val job: Job

    init {
        job = scope.launch {
            while (true) {
                delay(window)
                val count: Int = frequencyThisWindow.getAndSet(0)
                try {
                    onWindowCross(count)
                } catch (e: Exception) {
                    // Log error but continue tracking
                }
            }
        }
    }

    fun mark() {
        frequencyThisWindow.incrementAndGet()
    }

    fun cancel() {
        job.cancel()
    }
}
```

**Key changes:**
- `AtomicInteger` for thread-safe counting
- Exception handling for callback
- Explicit typing per Kotlin rules

The class works well for your use case - just call `mark()` each time you want to count an execution.

