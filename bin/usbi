#!/bin/bash

# Trimmed USB info from system_profiler
# Converted from Fish to Bash for cross-platform use

usbi() {
    local mode="default"
    local use_color="1"

    # Disable colors if output is not to a terminal
    if [[ ! -t 1 ]]; then
        use_color="0"
    fi

    # Parse arguments
    for arg in "$@"; do
        case "$arg" in
            --raw)
                mode="raw"
                ;;
            --speed)
                mode="speed"
                ;;
            --power)
                mode="power"
                ;;
            --problems)
                mode="problems"
                ;;
            --location)
                mode="location"
                ;;
            --summary)
                mode="summary"
                ;;
            --no-color)
                use_color="0"
                ;;
            --help|-h)
                cat << 'EOF'
Usage: usbi [MODE]
Modes:
  default:    Enhanced info with categories, vendor names, and health indicators
  --raw:      Raw system_profiler output with normalized whitespace
  --speed:    Speed-focused tree with actual values [category speed]
  --power:    Power-focused tree with usage warnings [req/avail mA]
  --problems: Show only devices with issues (power, speed, driver problems)
  --location: Show location info along with manufacturer details
  --summary:  Port utilization, power totals, device counts
  --no-color: Disable colored output

Health Indicators:
  üî¥ Critical power usage (>95% of available)
  üü° High power usage (>80% of available)
  ‚ùå Problem device (missing info or errors)
EOF
                return 0
                ;;
        esac
    done

    if [[ "$mode" == "raw" ]]; then
        # Use the same awk parsing logic but output everything with proper indentation
        system_profiler SPUSBDataType | awk '
            function trim(s){ gsub(/^[[:space:]]+|[[:space:]]+$/,"",s); return s }
            function indent(n){ s=""; for(i=0;i<n;i++) s=s "  "; return s }

            BEGIN { print "USB:" }

            {
                # Parse indentation
                sp = 0
                while (substr($0, sp+1, 1) == " ") sp++
                curr_level = int(sp/2)

                line = $0
                gsub(/\r/,"",line)
                line = trim(line)

                if (line == "") {
                    print ""
                    next
                }
                if (line == "USB:") next

                # Print with proper hierarchical indentation
                print indent(curr_level) line
            }
        '
        return $?
    fi

    # Parse system_profiler and emit the desired formats.
    # We'll use awk for structured parsing and formatting.
    # First pass to collect all devices, second pass to display with proper tree
    system_profiler SPUSBDataType | awk -v MODE="$mode" -v USE_COLOR="$use_color" -v USE_ASCII="${USE_ASCII:-0}" '
        function trim(s){ gsub(/^[[:space:]]+|[[:space:]]+$/,"",s); return s }
        function indent(n){ s=""; for(i=0;i<n;i++) s=s "  "; return s }

        # Tree drawing functions
        function tree_prefix(level, is_last, tree_state) {
            if (level == 0) return ""

            # Choose characters based on ASCII mode
            vert = (USE_ASCII == "1") ? "|" : "‚îÇ"
            branch = (USE_ASCII == "1") ? "+-" : "‚îú‚îÄ"
            last_branch = (USE_ASCII == "1") ? "\\-" : "‚îî‚îÄ"

            prefix = ""
            for (i = 1; i < level; i++) {
                if (tree_continues[i]) prefix = prefix vert "  "
                else prefix = prefix "   "
            }

            if (is_last) {
                prefix = prefix last_branch " "
                tree_continues[level] = 0
            } else {
                prefix = prefix branch " "
                tree_continues[level] = 1
            }

            return prefix
        }

        # Store devices at each level to determine last child
        function peek_next_level() {
            # Look ahead to see if next non-empty line has lower or equal indentation
            # This helps determine if current device is last at its level
            # Note: simplified version - in production would need full lookahead
            return 0
        }

        # Enhanced vendor database
        function get_vendor_name(vid, orig_name) {
            vid = tolower(vid)
            if (vid ~ /0x18d1/) return "Google"
            if (vid ~ /0x05ac/) return "Apple"
            if (vid ~ /0x1532/) return "Razer"
            if (vid ~ /0x046d/) return "Logitech"
            if (vid ~ /0x8087/) return "Intel"
            if (vid ~ /0x2188/) return "CalDigit"
            if (vid ~ /0x1a40/) return "Terminus Tech"
            if (vid ~ /0x1a86/) return "QinHeng Electronics"
            if (vid ~ /0x0781/) return "SanDisk"
            if (vid ~ /0x0930/) return "Toshiba"
            if (vid ~ /0x152d/) return "JMicron"
            if (vid ~ /0x174c/) return "ASMedia"
            if (vid ~ /0x1058/) return "Western Digital"
            if (vid ~ /0x04e8/) return "Samsung"
            if (vid ~ /0x0bc2/) return "Seagate"
            return orig_name  # fallback to original
        }

        # Device categorization
        function categorize_device(name, vid, pid) {
            name_lower = tolower(name)
            if (name_lower ~ /hub/) return "Hub"
            if (name_lower ~ /mouse|trackpad|touchpad/) return "Mouse/Trackpad"
            if (name_lower ~ /keyboard/) return "Keyboard"
            if (name_lower ~ /phone|pixel|iphone|android/) return "Phone"
            if (name_lower ~ /drive|disk|storage|ssd|hdd/) return "Storage"
            if (name_lower ~ /camera|webcam/) return "Camera"
            if (name_lower ~ /audio|speaker|headphone|microphone/) return "Audio"
            if (name_lower ~ /printer/) return "Printer"
            if (name_lower ~ /adapter|dongle/) return "Adapter"
            if (name_lower ~ /composite/) return "Composite Device"
            return "Unknown Device"
        }

        # Color functions - check if colors are enabled
        function red(text) { return (USE_COLOR == "1") ? sprintf("\033[31m%s\033[0m", text) : text }
        function green(text) { return (USE_COLOR == "1") ? sprintf("\033[32m%s\033[0m", text) : text }
        function yellow(text) { return (USE_COLOR == "1") ? sprintf("\033[33m%s\033[0m", text) : text }
        function blue(text) { return (USE_COLOR == "1") ? sprintf("\033[34m%s\033[0m", text) : text }
        function magenta(text) { return (USE_COLOR == "1") ? sprintf("\033[35m%s\033[0m", text) : text }
        function cyan(text) { return (USE_COLOR == "1") ? sprintf("\033[36m%s\033[0m", text) : text }
        function white(text) { return (USE_COLOR == "1") ? sprintf("\033[37m%s\033[0m", text) : text }
        function bold(text) { return (USE_COLOR == "1") ? sprintf("\033[1m%s\033[0m", text) : text }
        function dim(text) { return (USE_COLOR == "1") ? sprintf("\033[2m%s\033[0m", text) : text }

        # Health indicator functions with color
        function get_power_indicator(req, avail) {
            if (req == "" || avail == "" || avail == 0) return ""
            usage = (req / avail) * 100
            if (usage > 95) return red("üî¥")
            if (usage > 80) return yellow("üü°")
            return ""
        }

        function has_problems(name, speed, manuf, curr_req, curr_avail, vid, location) {
            # Missing critical info
            if (name == "" || speed == "") return 1
            # Power problems
            if (curr_req != "" && curr_avail != "" && curr_req > curr_avail) return 1
            # Very high power usage
            if (curr_req != "" && curr_avail != "" && (curr_req/curr_avail) > 0.95) return 1
            return 0
        }

        function has_non_power_problems(name, speed, manuf, curr_req, curr_avail, vid, location) {
            # Missing critical info
            if (name == "" || speed == "") return 1
            # Power demand exceeds supply (different from high usage)
            if (curr_req != "" && curr_avail != "" && curr_req > curr_avail) return 1
            # Could add other non-power issues here like speed mismatches, driver issues, etc.
            return 0
        }
        function cat_speed(spd,   lspd){
            lspd=tolower(spd)
            if (lspd ~ /1\.5 *mb\/s/) return "[low]"
            if (lspd ~ /12 *mb\/s/)  return "[full]"
            if (lspd ~ /480 *mb\/s/) return "[high]"
            if (lspd ~ /5 *gb\/s/)   return "[ss]"
            if (lspd ~ /10 *gb\/s/)  return "[ss+]"
            if (lspd ~ /20 *gb\/s/)  return "[ss20]"
            if (lspd ~ /40 *gb\/s/)  return "[ss40]"
            return "[]"
        }

        function get_transfer_rate(speed_cat) {
            if (speed_cat == "low") return dim("~0.2 MB/s max")
            else if (speed_cat == "full") return dim("~1.5 MB/s max")
            else if (speed_cat == "high") return dim("~60 MB/s max")
            else if (speed_cat == "ss") return dim("~625 MB/s max")
            else if (speed_cat == "ss+") return dim("~1.25 GB/s max")
            else if (speed_cat == "ss20") return dim("~2.5 GB/s max")
            else if (speed_cat == "ss40") return dim("~5 GB/s max")
            return ""
        }
        function is_hub(name){
            return (name ~ /Hub:?$/ || name ~ / Hub:?$/)
        }
        function flush_device(){
            if (dev_name == "") return

            # Store device info for later processing
            device_idx++
            devices[device_idx, "name"] = dev_name
            devices[device_idx, "level"] = level
            devices[device_idx, "speed"] = dev_speed
            devices[device_idx, "manuf"] = dev_manuf
            devices[device_idx, "curr_req"] = dev_curr_req
            devices[device_idx, "curr_avail"] = dev_curr_avail
            devices[device_idx, "location"] = dev_location
            devices[device_idx, "vid"] = dev_vid
            devices[device_idx, "pid"] = dev_pid
            devices[device_idx, "is_bus"] = is_bus
            devices[device_idx, "bus_driver"] = bus_driver

            # Increment counters
            if (!is_bus) {
                device_count++
                if (is_hub(dev_name)) hub_count++
                if (dev_curr_req != "") total_power_used += dev_curr_req
                if (dev_curr_avail != "") total_power_available += dev_curr_avail

                speed_cat = cat_speed(dev_speed)
                gsub(/\[|\]/, "", speed_cat)  # Remove brackets
                if (speed_cat != "") speed_categories[speed_cat]++

                if (has_problems(dev_name, dev_speed, dev_manuf, dev_curr_req, dev_curr_avail, dev_vid, dev_location)) {
                    problem_count++
                }
            }

            # reset fields for next device
            dev_name=""; dev_speed=""; dev_manuf=""; dev_curr_req=""; dev_curr_avail=""; dev_location=""; dev_vid=""; dev_pid=""; is_bus=0; bus_driver=""
        }

        function display_all_devices() {
            # Display all collected devices with proper tree structure
            for (idx = 1; idx <= device_idx; idx++) {
                dev_name = devices[idx, "name"]
                level = devices[idx, "level"]
                dev_speed = devices[idx, "speed"]
                dev_manuf = devices[idx, "manuf"]
                dev_curr_req = devices[idx, "curr_req"]
                dev_curr_avail = devices[idx, "curr_avail"]
                dev_location = devices[idx, "location"]
                dev_vid = devices[idx, "vid"]
                dev_pid = devices[idx, "pid"]
                is_bus = devices[idx, "is_bus"]
                bus_driver = devices[idx, "bus_driver"]

                # Determine if this is the last device at this level
                is_last = 1
                if (idx < device_idx) {
                    for (j = idx + 1; j <= device_idx; j++) {
                        if (devices[j, "level"] <= level) {
                            if (devices[j, "level"] == level) is_last = 0
                            break
                        }
                    }
                }

            # Show all devices with default format
            if (MODE != "raw") {
                # Show devices with problems mode filtering
                if (MODE == "problems" && !is_bus && !has_problems(dev_name, dev_speed, dev_manuf, dev_curr_req, dev_curr_avail, dev_vid, dev_location)) {
                    # Skip non-problem devices in problems mode
                } else if (MODE == "storage" && !is_bus && !is_hub(dev_name) && !(categorize_device(dev_name, dev_vid, dev_pid) ~ /üíæ Storage/ || dev_name ~ /drive|disk|storage|ssd|hdd/i || dev_name ~ /phone|pixel|iphone|android/i)) {
                    # Skip non-storage devices in storage mode (but include phones and always show hubs/buses)
                } else {

                    # Use tree drawing for all modes
                    prefix = tree_prefix(level, is_last)

                    if (is_bus) {
                        # Bus display - buses are always shown at root level without tree emoji
                        if (bus_driver != "") print blue(dev_name) " [" cyan(bus_driver) "]"
                        else print blue(dev_name)
                    } else {
                        # For non-bus devices, adjust the level for tree drawing
                        # Since buses are shown at root, their children should appear relative to the bus
                        # The bus is at level 2, its direct children at level 4, etc.
                        # We want to map: level 4 -> display_level 1, level 6 -> display_level 2, etc.
                        display_level = (level - 2) / 2
                        if (display_level < 1) display_level = 1

                        # Determine if this is the last device at this display level
                        display_is_last = 1
                        if (idx < device_idx) {
                            for (j = idx + 1; j <= device_idx; j++) {
                                if (devices[j, "is_bus"]) break  # Stop at next bus
                                next_display_level = (devices[j, "level"] - 2) / 2
                                if (next_display_level <= display_level) {
                                    if (next_display_level == display_level) display_is_last = 0
                                    break
                                }
                            }
                        }

                        prefix = tree_prefix(display_level, display_is_last)

                        # Enhanced vendor info
                        enhanced_manuf = dev_manuf
                        if (dev_vid != "" && dev_manuf != "") {
                            enhanced_vendor = get_vendor_name(dev_vid, dev_manuf)
                            if (enhanced_vendor != dev_manuf) {
                                enhanced_manuf = enhanced_vendor
                            }
                        }

                        # Get device category and health indicators
                        category = ""
                        health_indicators = ""

                        if (!is_hub(dev_name)) {
                            category = categorize_device(dev_name, dev_vid, dev_pid)

                            # Power health indicator - show in all modes except speed
                            if (MODE != "speed") {
                                power_indicator = get_power_indicator(dev_curr_req, dev_curr_avail)
                                if (power_indicator != "") health_indicators = health_indicators " " power_indicator
                            }

                            # Add slow mark for non-hubs - show in all modes except power
                            if (MODE != "power" && (cat_speed(dev_speed) == "[low]" || cat_speed(dev_speed) == "[full]")) {
                                health_indicators = health_indicators " *"
                            }

                            # Only add ‚ùå for non-power problems in problems mode or default mode
                            if ((MODE == "problems" || MODE == "default") && has_non_power_problems(dev_name, dev_speed, enhanced_manuf, dev_curr_req, dev_curr_avail, dev_vid, dev_location)) {
                                health_indicators = health_indicators " ‚ùå"
                            }
                        }

                        # Enhanced device display with category and health indicators
                        display_name = dev_name
                        if (is_hub(dev_name)) {
                            display_name = bold(dev_name)
                        } else if (category != "" && category !~ /Unknown/) {
                            display_name = category " " bold(dev_name)
                        } else {
                            display_name = bold(dev_name)
                        }
                        if (health_indicators != "") {
                            display_name = display_name health_indicators
                        }

                        print prefix display_name

                        # Create indent for attributes based on current tree state
                        attr_indent = ""
                        for (i = 1; i <= display_level; i++) {
                            if (i < display_level && tree_continues[i]) {
                                attr_indent = attr_indent (USE_ASCII == "1" ? "|" : "‚îÇ") "  "
                            } else if (i < display_level) {
                                attr_indent = attr_indent "   "
                            } else if (!display_is_last) {
                                attr_indent = attr_indent (USE_ASCII == "1" ? "|" : "‚îÇ") "  "
                            } else {
                                attr_indent = attr_indent "   "
                            }
                        }

                        # No special emoji-based indentation for hubs

                        # Speed line with category - color code by speed (skip for power, storage, and location modes)
                        if (dev_speed != "" && MODE != "power" && MODE != "storage" && MODE != "location") {
                            speed_cat = cat_speed(dev_speed)
                            gsub(/\[|\]/, "", speed_cat)
                            colored_speed = dev_speed
                            if (speed_cat == "low" || speed_cat == "full") colored_speed = red(dev_speed)
                            else if (speed_cat == "high") colored_speed = yellow(dev_speed)
                            else if (speed_cat == "ss" || speed_cat == "ss+") colored_speed = green(dev_speed)
                            else if (speed_cat == "ss20" || speed_cat == "ss40") colored_speed = cyan(dev_speed)

                            # Include transfer rate in speed display for all modes except --raw
                            spcat = (dev_speed != "" ? cat_speed(dev_speed) : "")
                            transfer_rate = get_transfer_rate(speed_cat)
                            if (transfer_rate != "" && MODE != "raw") {
                                printf "%s%-14s %s %s %s\n", attr_indent, dim("Speed:"), colored_speed, spcat, transfer_rate
                            } else {
                                printf "%s%-14s %s %s\n", attr_indent, dim("Speed:"), colored_speed, spcat
                            }
                        }

                        # Show manufacturer and vendor ID for default mode, vendor ID only for other modes
                        if (MODE == "default") {
                            if (dev_manuf != "") printf "%s%-14s %s\n", attr_indent, dim("Manufacturer:"), dev_manuf
                            if (dev_vid != "") printf "%s%-14s %s\n", attr_indent, dim("Vendor ID:"), dev_vid
                        } else {
                            if (dev_vid != "") printf "%s%-14s %s\n", attr_indent, dim("Vendor ID:"), dev_vid
                        }

                        # Power info - show for all modes except speed, storage, and location
                        if (dev_curr_req != "" && dev_curr_avail != "" && MODE != "speed" && MODE != "storage" && MODE != "location") {
                            usage = (dev_curr_req / dev_curr_avail) * 100
                            power_color = ""
                            if (usage > 95) power_color = red(sprintf("%dmA / %dmA (%.1f%%)", dev_curr_req, dev_curr_avail, usage))
                            else if (usage > 80) power_color = yellow(sprintf("%dmA / %dmA (%.1f%%)", dev_curr_req, dev_curr_avail, usage))
                            else power_color = green(sprintf("%dmA / %dmA (%.1f%%)", dev_curr_req, dev_curr_avail, usage))

                            printf "%s%-14s %s\n", attr_indent, dim("Power:"), power_color
                        }

                        # Location info - only show in location mode
                        if (dev_location != "" && MODE == "location") printf "%s%-14s %s\n", attr_indent, dim("Location:"), dim(dev_location)
                    }
                }
            }
            }
        }
        BEGIN{
            level=0; in_usb_root=0
            # Global counters for summary
            device_count = 0
            hub_count = 0
            total_power_used = 0
            total_power_available = 0
            problem_count = 0
            speed_categories["low"] = 0
            speed_categories["full"] = 0
            speed_categories["high"] = 0
            speed_categories["ss"] = 0
            speed_categories["ss+"] = 0
            speed_categories["ss20"] = 0
            speed_categories["ss40"] = 0

            # Arrays for storing device info for tree drawing
            device_idx = 0
            for (i = 0; i < 20; i++) tree_continues[i] = 0  # Track vertical lines

            # For tracking next levels (to determine last child)
            for (i = 0; i < 100; i++) next_level[i] = -1

            if (MODE != "summary") {
                print ""
            }
        }
        {
            # Keep original indentation width (2 spaces per nesting in SP output is typical but can vary).
            # Determine the indent level based on leading spaces divided by 2, but clamp non-negative.
            sp = 0
            while (substr($0, sp+1, 1) == " ") sp++
            curr_level = int(sp/2)

            line = $0
            gsub(/\r/,"",line)
            line = trim(line)

            # Blank lines just flush if needed (no-op here)
            if (line == "") next

            # USB root header
            if (line == "USB:") {
                # Already printed our own USB: header once
                next
            }

            # Detect Bus line with optional colon and handle driver info
            if (line ~ /^USB [0-9]+\.[0-9]+ Bus(:)?$/) {
                flush_device()
                level = curr_level
                dev_name = line; sub(/:$/,"",dev_name)
                is_bus=1
                next
            }

            # Host Controller Driver: for last seen bus
            if (line ~ /^Host Controller Driver:/) {
                split(line, a, ":"); bus_driver = trim(a[2])
                next
            }

            # Device name lines end with a colon in SP; keep name without colon
            if (line ~ /:$/) {
                flush_device()
                level = curr_level
                dev_name = line; sub(/:$/,"",dev_name)
                next
            }

            # Collect fields for current device
            if (line ~ /^Speed:/) {
                dev_speed = trim(substr(line, index(line,":")+1))
                next
            }
            if (line ~ /^Manufacturer:/) {
                dev_manuf = trim(substr(line, index(line,":")+1))
                next
            }
            if (line ~ /^Vendor ID:/) {
                dev_vid = trim(substr(line, index(line,":")+1))
                next
            }
            if (line ~ /^Product ID:/) {
                dev_pid = trim(substr(line, index(line,":")+1))
                next
            }
            if (line ~ /^Current Required \(mA\):/) {
                v = trim(substr(line, index(line,":")+1)); gsub(/[^0-9]/,"",v); dev_curr_req = v
                next
            }
            if (line ~ /^Current Available \(mA\):/) {
                v = trim(substr(line, index(line,":")+1)); gsub(/[^0-9]/,"",v); dev_curr_avail = v
                next
            }
            if (line ~ /^Location ID:/) {
                dev_location = trim(substr(line, index(line,":")+1))
                next
            }

            # On any other field, ignore in default/speed modes
        }
        END{
            flush_device()

            # Display devices for non-summary modes
            if (MODE != "summary") {
                display_all_devices()
            }

            # Add mode-specific information at the end
            if (MODE == "summary") {
                print ""
                print blue("USB Summary:")
                print "============"
                printf "Total Devices: %d (excluding hubs)\n", device_count - hub_count
                printf "Hubs: %d\n", hub_count
                print ""
                printf "Power Usage: %dmA used / %dmA available", total_power_used, total_power_available
                if (total_power_available > 0) {
                    usage_pct = (total_power_used / total_power_available) * 100
                    if (usage_pct > 95) printf " (%s)\n", red(sprintf("%.1f%%", usage_pct))
                    else if (usage_pct > 80) printf " (%s)\n", yellow(sprintf("%.1f%%", usage_pct))
                    else printf " (%s)\n", green(sprintf("%.1f%%", usage_pct))
                } else {
                    print ""
                }
                print ""
                print "Speed Distribution:"
                if (speed_categories["low"] > 0) printf "  %s %d devices\n", red("USB 1.0 (1.5 Mb/s):"), speed_categories["low"]
                if (speed_categories["full"] > 0) printf "  %s %d devices\n", red("USB 1.1 (12 Mb/s):"), speed_categories["full"]
                if (speed_categories["high"] > 0) printf "  %s %d devices\n", yellow("USB 2.0 (480 Mb/s):"), speed_categories["high"]
                if (speed_categories["ss"] > 0) printf "  %s %d devices\n", green("USB 3.0 (5 Gb/s):"), speed_categories["ss"]
                if (speed_categories["ss+"] > 0) printf "  %s %d devices\n", green("USB 3.1 (10 Gb/s):"), speed_categories["ss+"]
                if (speed_categories["ss20"] > 0) printf "  %s %d devices\n", cyan("USB 3.2 (20 Gb/s):"), speed_categories["ss20"]
                if (speed_categories["ss40"] > 0) printf "  %s %d devices\n", cyan("USB4 (40 Gb/s):"), speed_categories["ss40"]
            } else if (MODE == "speed") {
                print ""
                print blue("Speed Categories:")
                if (speed_categories["low"] > 0) printf "  %s %d devices\n", red("[low]  1.5 Mb/s   (USB 1.0)"), speed_categories["low"]
                if (speed_categories["full"] > 0) printf "  %s %d devices\n", red("[full] 12 Mb/s    (USB 1.1)"), speed_categories["full"]
                if (speed_categories["high"] > 0) printf "  %s %d devices\n", yellow("[high] 480 Mb/s   (USB 2.0)"), speed_categories["high"]
                if (speed_categories["ss"] > 0) printf "  %s %d devices\n", green("[ss]   5 Gb/s     (USB 3.0)"), speed_categories["ss"]
                if (speed_categories["ss+"] > 0) printf "  %s %d devices\n", green("[ss+]  10 Gb/s    (USB 3.1)"), speed_categories["ss+"]
                if (speed_categories["ss20"] > 0) printf "  %s %d devices\n", cyan("[ss20] 20 Gb/s    (USB 3.2)"), speed_categories["ss20"]
                if (speed_categories["ss40"] > 0) printf "  %s %d devices\n", cyan("[ss40] 40 Gb/s    (USB4)"), speed_categories["ss40"]
            } else if (MODE == "power") {
                print ""
                print blue("Power Summary:")
                printf "Total Power: %dmA used / %dmA available", total_power_used, total_power_available
                if (total_power_available > 0) {
                    usage_pct = (total_power_used / total_power_available) * 100
                    if (usage_pct > 95) printf " (%s)\n", red(sprintf("%.1f%%", usage_pct))
                    else if (usage_pct > 80) printf " (%s)\n", yellow(sprintf("%.1f%%", usage_pct))
                    else printf " (%s)\n", green(sprintf("%.1f%%", usage_pct))
                } else {
                    print ""
                }
                print "üî¥ = Critical (>95%), üü° = High (>80%), üü¢ = Normal (<80%)"
            } else if (MODE == "problems") {
                print ""
                if (problem_count == 0) {
                    print green("‚úÖ No USB problems detected!")
                } else {
                    printf "%s %d device(s) with problems\n", red("‚ö†Ô∏è Found"), problem_count
                    print "üî¥ = Critical power (>95%), üü° = High power (>80%), ‚ùå = Missing info/errors"
                }
            } else if (MODE == "storage") {
                # Count storage devices
                storage_count = 0
                for (cat in speed_categories) {
                    if (speed_categories[cat] > 0) storage_count += speed_categories[cat]
                }
                print ""
                print blue("Storage Performance Estimates:")
                if (speed_categories["high"] > 0) printf "  %s ~60 MB/s max (%d devices)\n", yellow("USB 2.0:"), speed_categories["high"]
                if (speed_categories["ss"] > 0) printf "  %s ~625 MB/s max (%d devices)\n", green("USB 3.0:"), speed_categories["ss"]
                if (speed_categories["ss+"] > 0) printf "  %s ~1.25 GB/s max (%d devices)\n", green("USB 3.1+:"), speed_categories["ss+"]
                if (speed_categories["ss20"] > 0 || speed_categories["ss40"] > 0) {
                    fast_count = speed_categories["ss20"] + speed_categories["ss40"]
                    printf "  %s ~2.5+ GB/s max (%d devices)\n", cyan("USB 3.2/4:"), fast_count
                }
            } else if (MODE == "json") {
                print ""
                print "  ],"
                printf "  \"summary\": {\n"
                printf "    \"total_devices\": %d,\n", device_count - hub_count
                printf "    \"hubs\": %d,\n", hub_count
                printf "    \"problems\": %d,\n", problem_count
                printf "    \"power_used\": %d,\n", total_power_used
                printf "    \"power_available\": %d\n", total_power_available
                printf "  }\n"
                print "}"
            } else if (MODE == "default") {
                # Add legend for default tree view
                print ""
                print dim("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
                print dim("Speed:  ") green("Green=USB3+") " " yellow("Yellow=USB2") " " red("Red=USB1") " ‚Ä¢ " dim("Info in parentheses")
            }
        }
    '
}

# If script is executed directly (not sourced), run the function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    usbi "$@"
fi