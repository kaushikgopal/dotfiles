#!/bin/bash

# Trimmed USB info from system_profiler
# Converted from Fish to Bash for cross-platform use
# Usage: source this file to define `usbi`, or execute to run.

usbi() {
    local mode="default"
    local use_color="1"

    # Disable colors if output is not to a terminal
    if [[ ! -t 1 ]]; then
        use_color="0"
    fi

    # Parse arguments
    for arg in "$@"; do
        case "$arg" in
            --raw)
                mode="raw"
                ;;
            --speed)
                mode="speed"
                ;;
            --power)
                mode="power"
                ;;
            --problems)
                mode="problems"
                ;;
            --location)
                mode="location"
                ;;
            --summary)
                mode="summary"
                ;;
            --no-color)
                use_color="0"
                ;;
            --help|-h)
                cat << 'EOF'
Usage: usbi [MODE]
Modes:
  default:    Enhanced info with categories, vendor names, and health indicators
  --raw:      Raw system_profiler output with normalized whitespace
  --speed:    Speed-focused tree with actual values [category speed]
  --power:    Power-focused tree with usage warnings [req/avail mA]
  --problems: Show only devices with issues (power, speed, driver problems)
  --location: Show location info along with manufacturer details
  --summary:  Port utilization, power totals, device counts
  --no-color: Disable colored output

Color thresholds (power): red >90%, yellow >50%, green otherwise
EOF
                return 0
                ;;
        esac
    done

    if [[ "$mode" == "raw" ]]; then
        # Use the same awk parsing logic but output everything with proper indentation
        system_profiler SPUSBDataType | awk '
            function trim(s){ gsub(/^[[:space:]]+|[[:space:]]+$/,"",s); return s }
            function indent(n){ s=""; for(i=0;i<n;i++) s=s "  "; return s }

            BEGIN { print "USB:" }

            {
                # Parse indentation
                sp = 0
                while (substr($0, sp+1, 1) == " ") sp++
                curr_level = int(sp/2)

                line = $0
                gsub(/\r/,"",line)
                line = trim(line)

                if (line == "") {
                    print ""
                    next
                }
                if (line == "USB:") next

                # Print with proper hierarchical indentation
                print indent(curr_level) line
            }
        '
        return $?
    fi

    # Parse system_profiler and emit the desired formats using awk.
    # Implementation notes:
    # - Single pass collects devices; final END block renders with tree layout.
    # - Helpers are grouped by purpose: utilities, tree, domain, presentation.
    system_profiler SPUSBDataType | awk -v MODE="$mode" -v USE_COLOR="$use_color" -v USE_ASCII="${USE_ASCII:-0}" '
        #
        # Utility helpers
        #
        function trim(s){ gsub(/^[[:space:]]+|[[:space:]]+$/,"",s); return s }
        function indent(n){ s=""; for(i=0;i<n;i++) s=s "  "; return s }

        #
        # Tree rendering helpers
        #
        function tree_prefix(level, is_last, tree_state) {
            if (level == 0) return ""

            # Choose characters based on ASCII mode
            vert = (USE_ASCII == "1") ? "|" : "â”‚"
            branch = (USE_ASCII == "1") ? "+-" : "â”œâ”€"
            last_branch = (USE_ASCII == "1") ? "\\-" : "â””â”€"

            prefix = ""
            for (i = 1; i < level; i++) {
                if (tree_continues[i]) prefix = prefix vert "  "
                else prefix = prefix "   "
            }

            if (is_last) {
                prefix = prefix last_branch " "
                tree_continues[level] = 0
            } else {
                prefix = prefix branch " "
                tree_continues[level] = 1
            }

            return prefix
        }

        # Map SP nesting level to display tree level
        function compute_display_level(raw_level,    dl){
            dl = (raw_level - 2) / 2
            if (dl < 1) dl = 1
            return dl
        }

        # Build the attribute indentation for aligned key/value rows
        function build_attr_indent(display_level, display_is_last,    i, out, vert){
            out = ""
            vert = (USE_ASCII == "1") ? "|" : "â”‚"
            for (i = 1; i <= display_level; i++) {
                if (i < display_level && tree_continues[i]) {
                    out = out vert "  "
                } else if (i < display_level) {
                    out = out "   "
                } else if (!display_is_last) {
                    out = out vert "  "
                } else {
                    out = out "   "
                }
            }
            return out
        }

        #
        # Domain helpers
        #

        # Enhanced vendor database
        function get_vendor_name(vid, orig_name) {
            vid = tolower(vid)
            if (vid ~ /0x18d1/) return "Google"
            if (vid ~ /0x05ac/) return "Apple"
            if (vid ~ /0x1532/) return "Razer"
            if (vid ~ /0x046d/) return "Logitech"
            if (vid ~ /0x8087/) return "Intel"
            if (vid ~ /0x2188/) return "CalDigit"
            if (vid ~ /0x1a40/) return "Terminus Tech"
            if (vid ~ /0x1a86/) return "QinHeng Electronics"
            if (vid ~ /0x0781/) return "SanDisk"
            if (vid ~ /0x0930/) return "Toshiba"
            if (vid ~ /0x152d/) return "JMicron"
            if (vid ~ /0x174c/) return "ASMedia"
            if (vid ~ /0x1058/) return "Western Digital"
            if (vid ~ /0x04e8/) return "Samsung"
            if (vid ~ /0x0bc2/) return "Seagate"
            return orig_name  # fallback to original
        }

        # Device categorization
        function categorize_device(name, vid, pid) {
            name_lower = tolower(name)
            if (name_lower ~ /hub/) return "Hub"
            if (name_lower ~ /mouse|trackpad|touchpad/) return "Mouse/Trackpad"
            if (name_lower ~ /keyboard/) return "Keyboard"
            if (name_lower ~ /phone|pixel|iphone|android/) return "Phone"
            if (name_lower ~ /drive|disk|storage|ssd|hdd/) return "Storage"
            if (name_lower ~ /camera|webcam/) return "Camera"
            if (name_lower ~ /audio|speaker|headphone|microphone/) return "Audio"
            if (name_lower ~ /printer/) return "Printer"
            if (name_lower ~ /adapter|dongle/) return "Adapter"
            if (name_lower ~ /composite/) return "Composite Device"
            return "Unknown Device"
        }

        # Color functions - check if colors are enabled
        function red(text) { return (USE_COLOR == "1") ? sprintf("\033[31m%s\033[0m", text) : text }
        function green(text) { return (USE_COLOR == "1") ? sprintf("\033[32m%s\033[0m", text) : text }
        function yellow(text) { return (USE_COLOR == "1") ? sprintf("\033[33m%s\033[0m", text) : text }
        function blue(text) { return (USE_COLOR == "1") ? sprintf("\033[34m%s\033[0m", text) : text }
        function magenta(text) { return (USE_COLOR == "1") ? sprintf("\033[35m%s\033[0m", text) : text }
        function cyan(text) { return (USE_COLOR == "1") ? sprintf("\033[36m%s\033[0m", text) : text }
        function white(text) { return (USE_COLOR == "1") ? sprintf("\033[37m%s\033[0m", text) : text }
        function bold(text) { return (USE_COLOR == "1") ? sprintf("\033[1m%s\033[0m", text) : text }
        function dim(text) { return (USE_COLOR == "1") ? sprintf("\033[2m%s\033[0m", text) : text }
        # Bold helpers that do not reset all attributes (to preserve outer colors)
        function bold_on(){ return (USE_COLOR == "1") ? "\033[1m" : "" }
        function bold_off(){ return (USE_COLOR == "1") ? "\033[22m" : "" }

        # Choose color for the given speed string by USB version token
        function choose_speed_color(speed_string, speed_cat,    colored){
            colored = speed_string
            if (speed_cat == "USB 1.0" || speed_cat == "USB 1.1") colored = red(speed_string)
            else if (speed_cat == "USB 2.0") colored = yellow(speed_string)
            else if (speed_cat == "USB 3.0" || speed_cat == "USB 3.1") colored = green(speed_string)
            else if (speed_cat == "USB 3.2" || speed_cat == "USB4") colored = cyan(speed_string)
            return colored
        }

        # Prefer known vendor name when possible
        function enhanced_manufacturer(vid, manuf,    v){
            if (vid != "" && manuf != "") {
                v = get_vendor_name(vid, manuf)
                if (v != manuf) return v
            }
            return manuf
        }

        # Legacy indicator function (no emoji output; color alone is used elsewhere)
        function get_power_indicator(req, avail) { return "" }

        function has_problems(name, speed, manuf, curr_req, curr_avail, vid, location) {
            # Missing critical info
            if (name == "" || speed == "") return 1
            # Power problems
            if (curr_req != "" && curr_avail != "" && curr_req > curr_avail) return 1
            # Very high power usage
            if (curr_req != "" && curr_avail != "" && (curr_req/curr_avail) > 0.95) return 1
            return 0
        }

        function has_non_power_problems(name, speed, manuf, curr_req, curr_avail, vid, location) {
            # Missing critical info
            if (name == "" || speed == "") return 1
            # Power demand exceeds supply (different from high usage)
            if (curr_req != "" && curr_avail != "" && curr_req > curr_avail) return 1
            # Could add other non-power issues here like speed mismatches, driver issues, etc.
            return 0
        }
        function cat_speed(spd,   lspd){
            lspd=tolower(spd)
            if (lspd ~ /1\.5 *mb\/s/) return "[USB 1.0]"
            if (lspd ~ /12 *mb\/s/)  return "[USB 1.1]"
            if (lspd ~ /480 *mb\/s/) return "[USB 2.0]"
            if (lspd ~ /5 *gb\/s/)   return "[USB 3.0]"
            if (lspd ~ /10 *gb\/s/)  return "[USB 3.1]"
            if (lspd ~ /20 *gb\/s/)  return "[USB 3.2]"
            if (lspd ~ /40 *gb\/s/)  return "[USB4]"
            return "[]"
        }

        function get_transfer_rate(speed_cat) {
            if (speed_cat == "USB 1.0") return "~0.2 MB/s max"
            else if (speed_cat == "USB 1.1") return "~1.5 MB/s max"
            else if (speed_cat == "USB 2.0") return "~60 MB/s max"
            else if (speed_cat == "USB 3.0") return "~625 MB/s max"
            else if (speed_cat == "USB 3.1") return "~1.25 GB/s max"
            else if (speed_cat == "USB 3.2") return "~2.5 GB/s max"
            else if (speed_cat == "USB4") return "~5 GB/s max"
            return ""
        }

        # Unified Speed summary renderer
        function render_speed_summary() {
            print blue("Speed:")
            if (speed_categories["USB 1.0"] > 0) printf "  %s %10s %14s %3d devices\n", red("[USB 1.0]"), "1.5 Mb/s", "(USB 1.0)", speed_categories["USB 1.0"]
            if (speed_categories["USB 1.1"] > 0) printf "  %s %10s %14s %3d devices\n", red("[USB 1.1]"), "12 Mb/s", "(USB 1.1)", speed_categories["USB 1.1"]
            if (speed_categories["USB 2.0"] > 0) printf "  %s %10s %14s %3d devices\n", yellow("[USB 2.0]"), "480 Mb/s", "(USB 2.0)", speed_categories["USB 2.0"]
            if (speed_categories["USB 3.0"] > 0) printf "  %s %10s %14s %3d devices\n", green("[USB 3.0]"), "5 Gb/s", "(USB 3.0)", speed_categories["USB 3.0"]
            if (speed_categories["USB 3.1"] > 0) printf "  %s %10s %14s %3d devices\n", green("[USB 3.1]"), "10 Gb/s", "(USB 3.1)", speed_categories["USB 3.1"]
            if (speed_categories["USB 3.2"] > 0) printf "  %s %10s %14s %3d devices\n", cyan("[USB 3.2]"), "20 Gb/s", "(USB 3.2)", speed_categories["USB 3.2"]
            if (speed_categories["USB4"] > 0) printf "  %s %10s %14s %3d devices\n", cyan("[USB4]"), "40 Gb/s", "(USB4)", speed_categories["USB4"]
        }

        # Unified Power summary renderer (new thresholds and brackets)
        function render_power_summary() {
            print blue("Power:")
            total_text = sprintf("%dmA used / %dmA available [%.1f%%]", total_power_used, total_power_available, (total_power_available>0? (total_power_used/total_power_available)*100 : 0))

            usage_pct = (total_power_available > 0) ? (total_power_used / total_power_available) * 100 : 0
            colored_total = total_text
            if (usage_pct > 90) colored_total = red(total_text)
            else if (usage_pct > 50) colored_total = yellow(total_text)
            else colored_total = green(total_text)

            printf "  %-10s %s\n", "Total", colored_total
            printf "                %s\n", green("< 50%")
            printf "                %s\n", yellow("> 50%")
            printf "                %s\n", red("> 90%")
        }
        function is_hub(name){
            return (name ~ /Hub:?$/ || name ~ / Hub:?$/)
        }
        function flush_device(){
            if (dev_name == "") return

            # Store device info for later processing
            device_idx++
            devices[device_idx, "name"] = dev_name
            devices[device_idx, "level"] = level
            devices[device_idx, "speed"] = dev_speed
            devices[device_idx, "manuf"] = dev_manuf
            devices[device_idx, "curr_req"] = dev_curr_req
            devices[device_idx, "curr_avail"] = dev_curr_avail
            devices[device_idx, "location"] = dev_location
            devices[device_idx, "vid"] = dev_vid
            devices[device_idx, "pid"] = dev_pid
            devices[device_idx, "is_bus"] = is_bus
            devices[device_idx, "bus_driver"] = bus_driver

            # Increment counters
            if (!is_bus) {
                device_count++
                if (is_hub(dev_name)) hub_count++
                if (dev_curr_req != "") total_power_used += dev_curr_req
                if (dev_curr_avail != "") total_power_available += dev_curr_avail

                speed_cat = cat_speed(dev_speed)
                gsub(/\[|\]/, "", speed_cat)  # Remove brackets
                if (speed_cat != "") speed_categories[speed_cat]++

                if (has_problems(dev_name, dev_speed, dev_manuf, dev_curr_req, dev_curr_avail, dev_vid, dev_location)) {
                    problem_count++
                }
            }

            # reset fields for next device
            dev_name=""; dev_speed=""; dev_manuf=""; dev_curr_req=""; dev_curr_avail=""; dev_location=""; dev_vid=""; dev_pid=""; is_bus=0; bus_driver=""
        }

        function display_all_devices() {
            # Display all collected devices with proper tree structure
            for (idx = 1; idx <= device_idx; idx++) {
                dev_name = devices[idx, "name"]
                level = devices[idx, "level"]
                dev_speed = devices[idx, "speed"]
                dev_manuf = devices[idx, "manuf"]
                dev_curr_req = devices[idx, "curr_req"]
                dev_curr_avail = devices[idx, "curr_avail"]
                dev_location = devices[idx, "location"]
                dev_vid = devices[idx, "vid"]
                dev_pid = devices[idx, "pid"]
                is_bus = devices[idx, "is_bus"]
                bus_driver = devices[idx, "bus_driver"]

                # Determine if this is the last device at this level
                is_last = 1
                if (idx < device_idx) {
                    for (j = idx + 1; j <= device_idx; j++) {
                        if (devices[j, "level"] <= level) {
                            if (devices[j, "level"] == level) is_last = 0
                            break
                        }
                    }
                }

            # Show all devices with default format
            if (MODE != "raw") {
                # Show devices with problems mode filtering
                if (MODE == "problems" && !is_bus && !has_problems(dev_name, dev_speed, dev_manuf, dev_curr_req, dev_curr_avail, dev_vid, dev_location)) {
                    # Skip non-problem devices in problems mode
                } else if (MODE == "storage" && !is_bus && !is_hub(dev_name) && !(categorize_device(dev_name, dev_vid, dev_pid) ~ /ðŸ’¾ Storage/ || dev_name ~ /drive|disk|storage|ssd|hdd/i || dev_name ~ /phone|pixel|iphone|android/i)) {
                    # Skip non-storage devices in storage mode (but include phones and always show hubs/buses)
                } else {

                    # Use tree drawing for all modes
                    prefix = tree_prefix(level, is_last)

                    if (is_bus) {
                        # Bus display - buses are always shown at root level without tree emoji
                        if (bus_driver != "") print blue(dev_name) " [" cyan(bus_driver) "]"
                        else print blue(dev_name)
                    } else {
                        # For non-bus devices, adjust the level for tree drawing
                        # Since buses are shown at root, their children should appear relative to the bus
                        display_level = compute_display_level(level)

                        # Determine if this is the last device at this display level
                        display_is_last = 1
                        if (idx < device_idx) {
                            for (j = idx + 1; j <= device_idx; j++) {
                                if (devices[j, "is_bus"]) break  # Stop at next bus
                                next_display_level = (devices[j, "level"] - 2) / 2
                                if (next_display_level <= display_level) {
                                    if (next_display_level == display_level) display_is_last = 0
                                    break
                                }
                            }
                        }

                        prefix = tree_prefix(display_level, display_is_last)

                        # Enhanced vendor info
                        enhanced_manuf = enhanced_manufacturer(dev_vid, dev_manuf)

                        # Get device category and health indicators
                        category = ""
                        health_indicators = ""

                        if (!is_hub(dev_name)) {
                            category = categorize_device(dev_name, dev_vid, dev_pid)

                            # Power health indicator: no longer shown on device line (shown on Power line only)

                            # Add slow mark for non-hubs - show in all modes except power
                            speed_bracketed = (dev_speed != "" ? cat_speed(dev_speed) : "")
                            if (MODE != "power" && (speed_bracketed == "[USB 1.0]" || speed_bracketed == "[USB 1.1]" || speed_bracketed == "[USB 2.0]")) {
                                health_indicators = health_indicators " *"
                            }

                            # Only add problem marker (text, no emoji) for non-power problems
                            if ((MODE == "problems" || MODE == "default") && has_non_power_problems(dev_name, dev_speed, enhanced_manuf, dev_curr_req, dev_curr_avail, dev_vid, dev_location)) {
                                health_indicators = health_indicators " " red("[Problem]")
                            }
                        }

                        # Enhanced device display with category and health indicators
                        display_name = dev_name
                        if (is_hub(dev_name)) {
                            display_name = bold(dev_name)
                        } else if (category != "" && category !~ /Unknown/) {
                            display_name = category " " bold(dev_name)
                        } else {
                            display_name = bold(dev_name)
                        }
                        if (health_indicators != "") {
                            display_name = display_name health_indicators
                        }

                        print prefix display_name

                        # Create indent for attributes based on current tree state
                        attr_indent = build_attr_indent(display_level, display_is_last)

                        # No special emoji-based indentation for hubs

                        # Speed line with category - color whole line, bracket bolded (skip for power, storage, location)
                        if (dev_speed != "" && MODE != "power" && MODE != "storage" && MODE != "location") {
                            speed_cat_br = cat_speed(dev_speed)
                            speed_cat = speed_cat_br
                            gsub(/\[|\]/, "", speed_cat)  # e.g., USB 2.0
                            transfer_rate = get_transfer_rate(speed_cat)

                            # Build line text with bolded bracket
                            line_text = sprintf("%-14s %s %s%s%s", "Speed:", dev_speed, bold_on(), speed_cat_br, bold_off())
                            if (transfer_rate != "") line_text = line_text " " transfer_rate

                            colored_line = choose_speed_color(line_text, speed_cat)
                            printf "%s%s\n", attr_indent, colored_line
                        }

                        # Show manufacturer and vendor ID for default mode, vendor ID only for other modes
                        if (MODE == "default") {
                            if (dev_manuf != "") printf "%s%-14s %s\n", attr_indent, dim("Manufacturer:"), dev_manuf
                            if (dev_vid != "") printf "%s%-14s %s\n", attr_indent, dim("Vendor ID:"), dev_vid
                        } else {
                            if (dev_vid != "") printf "%s%-14s %s\n", attr_indent, dim("Vendor ID:"), dev_vid
                        }

                        # Power info - show for all modes except speed, storage, and location (no emoji indicators)
                        if (dev_curr_req != "" && dev_curr_avail != "" && MODE != "speed" && MODE != "storage" && MODE != "location") {
                            usage = (dev_curr_req / dev_curr_avail) * 100
                            power_text = sprintf("%dmA/%dmA [%.1f%%]", dev_curr_req, dev_curr_avail, usage)
                            if (usage > 90) power_text = red(power_text)
                            else if (usage > 50) power_text = yellow(power_text)
                            else power_text = green(power_text)

                            printf "%s%-14s %s\n", attr_indent, dim("Power:"), power_text
                        }

                        # Location info - only show in location mode
                        if (dev_location != "" && MODE == "location") printf "%s%-14s %s\n", attr_indent, dim("Location:"), dim(dev_location)
                    }
                }
            }
            }
        }
        BEGIN{
            level=0; in_usb_root=0
            # Global counters for summary
            device_count = 0
            hub_count = 0
            total_power_used = 0
            total_power_available = 0
            problem_count = 0
            speed_categories["USB 1.0"] = 0
            speed_categories["USB 1.1"] = 0
            speed_categories["USB 2.0"] = 0
            speed_categories["USB 3.0"] = 0
            speed_categories["USB 3.1"] = 0
            speed_categories["USB 3.2"] = 0
            speed_categories["USB4"] = 0

            # Arrays for storing device info for tree drawing
            device_idx = 0
            for (i = 0; i < 20; i++) tree_continues[i] = 0  # Track vertical lines

            # For tracking next levels (to determine last child)
            for (i = 0; i < 100; i++) next_level[i] = -1

            if (MODE != "summary") {
                print ""
            }
        }
        {
            # Keep original indentation width (2 spaces per nesting in SP output is typical but can vary).
            # Determine the indent level based on leading spaces divided by 2, but clamp non-negative.
            sp = 0
            while (substr($0, sp+1, 1) == " ") sp++
            curr_level = int(sp/2)

            line = $0
            gsub(/\r/,"",line)
            line = trim(line)

            # Blank lines just flush if needed (no-op here)
            if (line == "") next

            # USB root header
            if (line == "USB:") {
                # Already printed our own USB: header once
                next
            }

            # Detect Bus line with optional colon and handle driver info
            if (line ~ /^USB [0-9]+\.[0-9]+ Bus(:)?$/) {
                flush_device()
                level = curr_level
                dev_name = line; sub(/:$/,"",dev_name)
                is_bus=1
                next
            }

            # Host Controller Driver: for last seen bus
            if (line ~ /^Host Controller Driver:/) {
                split(line, a, ":"); bus_driver = trim(a[2])
                next
            }

            # Device name lines end with a colon in SP; keep name without colon
            if (line ~ /:$/) {
                flush_device()
                level = curr_level
                dev_name = line; sub(/:$/,"",dev_name)
                next
            }

            # Collect fields for current device
            if (line ~ /^Speed:/) {
                dev_speed = trim(substr(line, index(line,":")+1))
                next
            }
            if (line ~ /^Manufacturer:/) {
                dev_manuf = trim(substr(line, index(line,":")+1))
                next
            }
            if (line ~ /^Vendor ID:/) {
                dev_vid = trim(substr(line, index(line,":")+1))
                next
            }
            if (line ~ /^Product ID:/) {
                dev_pid = trim(substr(line, index(line,":")+1))
                next
            }
            if (line ~ /^Current Required \(mA\):/) {
                v = trim(substr(line, index(line,":")+1)); gsub(/[^0-9]/,"",v); dev_curr_req = v
                next
            }
            if (line ~ /^Current Available \(mA\):/) {
                v = trim(substr(line, index(line,":")+1)); gsub(/[^0-9]/,"",v); dev_curr_avail = v
                next
            }
            if (line ~ /^Location ID:/) {
                dev_location = trim(substr(line, index(line,":")+1))
                next
            }

            # On any other field, ignore in default/speed modes
        }
        END{
            flush_device()

            # Display devices for non-summary modes
            if (MODE != "summary") {
                display_all_devices()
            }

            # Add mode-specific information at the end
            if (MODE == "summary") {
                print ""
                print blue("USB Summary:")
                print "============"
                printf "Total Devices: %d (excluding hubs)\n", device_count - hub_count
                printf "Hubs: %d\n", hub_count
                print ""
                render_power_summary()
                print ""
                render_speed_summary()
            } else if (MODE == "speed") {
                print ""
                render_speed_summary()
            } else if (MODE == "power") {
                print ""
                render_power_summary()
            } else if (MODE == "problems") {
                print ""
                if (problem_count == 0) {
                    print green("No USB problems detected!")
                } else {
                    printf "%s %d device(s) with problems\n", red("Found"), problem_count
                }
            } else if (MODE == "storage") {
                # Count storage devices
                storage_count = 0
                for (cat in speed_categories) {
                    if (speed_categories[cat] > 0) storage_count += speed_categories[cat]
                }
                print ""
                print blue("Storage Performance Estimates:")
                if (speed_categories["USB 2.0"] > 0) printf "  %s ~60 MB/s max (%d devices)\n", yellow("USB 2.0:"), speed_categories["USB 2.0"]
                if (speed_categories["USB 3.0"] > 0) printf "  %s ~625 MB/s max (%d devices)\n", green("USB 3.0:"), speed_categories["USB 3.0"]
                if (speed_categories["USB 3.1"] > 0) printf "  %s ~1.25 GB/s max (%d devices)\n", green("USB 3.1:"), speed_categories["USB 3.1"]
                if (speed_categories["USB 3.2"] > 0 || speed_categories["USB4"] > 0) {
                    fast_count = speed_categories["USB 3.2"] + speed_categories["USB4"]
                    printf "  %s ~2.5+ GB/s max (%d devices)\n", cyan("USB 3.2/4:"), fast_count
                }
            } else if (MODE == "json") {
                print ""
                print "  ],"
                printf "  \"summary\": {\n"
                printf "    \"total_devices\": %d,\n", device_count - hub_count
                printf "    \"hubs\": %d,\n", hub_count
                printf "    \"problems\": %d,\n", problem_count
                printf "    \"power_used\": %d,\n", total_power_used
                printf "    \"power_available\": %d\n", total_power_available
                printf "  }\n"
                print "}"
            } else if (MODE == "default") {
                # Append power and speed summaries at the end of default view (unified renderers)
                print ""
                render_power_summary()
                print ""
                render_speed_summary()
            }
        }
    '
}

# If script is executed directly (not sourced), run the function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    usbi "$@"
fi